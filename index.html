<html>
   <head>
      <title>wrapperl</title>
      <link rel="stylesheet" href="github-markdown.css">
      <style>
         .markdown-body {
            min-width: 200px;
            max-width: 790px;
            margin: 0 auto;
            padding: 30px;
         }
      </style>
   </head>
   <body>
      <div class="markdown-body">
<h1 id="name">NAME</h1>

<p>wrapperl - wrapper for Perl customized invocation</p>

<h1 id="hurry-up">Hurry Up!</h1>

<pre><code># download in "visible" location
cd /usr/bin
# alias wget='curl -LO' # in case you need it
wget https://raw.githubusercontent.com/polettix/wrapperl/master/wrapperl
chmod +x wrapperl 

# set wrapperl.env for your project. Suppose you have a 'lib' directory
# with your stuff inside, and a 'local/lib/perl5' directory with the
# local installation of support modules, all inside /path/to/project
cd /path/to/project
cat &gt; wrapperl.env &lt;&lt;END
PERL5LIB(qw&lt; lib local/lib/perl5 &gt;);
PERL('/path/to/selected/bin/perl');
END

# start using it, most straightforward way is from hash-bang
cat &gt; program.pl &lt;&lt;END
#!/usr/bin/env wrapperl
print "using perl '$^X', \@INC contains:\n";
print "- '$_'\n" for @INC;
END
./program.pl
# ...

# you can access docs for locally installed modules
wrapperl -d Log::Log4perl::Tiny
</code></pre>

<h1 id="tldr">TL;DR</h1>

<p>… or an example is worth a whole manual sometimes.</p>

<p>First of all, download <code>wrapperl</code> from
<a href="https://raw.githubusercontent.com/polettix/wrapperl/master/wrapperl">https://raw.githubusercontent.com/polettix/wrapperl/master/wrapperl</a>
and put somewhere in the environments where you need it. It is not
necessary to put it in a directory in the <code>PATH</code>, although it is
suggested in order to access all functionalities and it will also be
assumed in the following of this example.</p>

<p>Let’s make a few assumptions:</p>

<ul>
  <li>you are in a sane environment where you managed to put <code>wrapperl</code>
somewhere in your <code>PATH</code> and you have a working <code>/usr/bin/env</code> (this
assumption is not so strong, as you can understand, but will help us
set a consistent hash-bang)</li>
  <li>
    <p>you will write your program and we will call it <code>prg</code>. To get the gist
of <code>wrapperl</code> you can start from this:</p>

    <pre><code>  #!/usr/bin/env wrapperl
  print "using perl '$^X', \@INC contains:\n";
  print "- '$_'\n" for @INC;
</code></pre>

    <p>If you didn’t manage to put <code>wrapperl</code> in <code>PATH</code>, or you don’t have
  <code>/usr/bin/env</code>, just put the path to <code>wrapperl</code> in the <em>hash-bang</em>,
  although you will then need to ensure that this choice will be
  true on all systems</p>
  </li>
  <li>you do your coding in a development environment where:
    <ul>
      <li>you develop <code>prg</code> inside directory <code>/home/me/program</code></li>
      <li><code>perl</code> is located at <code>/home/me/perl/bin/perl</code></li>
      <li>the modules you develop in association with <code>prg</code> are located in
  sub-directory <code>lib</code>. In addition, you keep a local library of
  support modules in sub-directory <code>local/lib/perl5</code> and you also
  want to include modules from non-standard absolute location
  <code>/path/to/some/lib</code> and relative location <code>another/lib</code> with respect
  to where you are calling the program for (you are generally advised
  against this, but the example shows that you can)</li>
    </ul>
  </li>
  <li>you deploy your program in a production environment with a different
setup, namely:
    <ul>
      <li>your program <code>prg.pl</code> is deployed in directory <code>/app/program</code></li>
      <li><code>perl</code> is located at <code>/approved/perl/bin/perl</code></li>
      <li>you still keep the layout with the <code>lib</code> and <code>local/lib/perl5</code>
  sub-directories, but all system-wide modules you need
  are stored in <code>/approved/lib</code>.</li>
    </ul>
  </li>
</ul>

<p>In both environments, you create a <code>wrapperl.env</code> file inside the root
directory of your project, which will hold configurations
that are specific for the specific environment it is located into.
In this example we will put it in the same directory as <code>prg</code>.</p>

<p>This is what you end up with in the development environment:</p>

<pre><code>me@devhost /home/me/program$ ls -l
-rwxr-xr-x 1 me me 74 Apr 23 22:28 prg
-rwxr-xr-x 1 me me 90 Apr 22 12:35 wrapperl.env

me@devhost /home/me/program$ cat wrapperl.env
PERL5LIB(
   qw&lt; lib local/lib/perl5 &gt;, # located as siblings of wrapperl.env
   [ qw&lt; /path/to/some/lib another/lib &gt; ],    # non-siblings paths
);
PERL('/home/me/perl/bin/perl');
</code></pre>

<p>This is what you have in the production environment:</p>

<pre><code>me@production /app/program$ ls -l
-rwxr-xr-x 1 me me 74 Apr 25 20:51 prg
-rwxr-xr-x 1 me me 66 Apr 25 20:51 wrapperl.env

me@production /app/program$ cat wrapperl.env
PERL5LIB(
   qw&lt; lib local/lib/perl5 &gt;, # located as siblings of wrapperl.env
   [ qw&lt; /approved/lib &gt; ],   # non-siblings paths
);
PERL('/approved/perl/bin/perl');
</code></pre>

<p>So yes, they two setups are mostly the same, except for the contents
of the <code>wrapperl.env</code> files, each containing configurations that
are environment-specific. You should be able to easily guess what the
two functions <code>PERL5LIB</code> and <code>PERL</code> do.</p>

<p>Now, you just execute your program. In the development environment:</p>

<pre><code>me@devhost /home/me/program$ ./prg
using perl '/home/me/perl/bin/perl', @INC contains:
- '/home/me/program/lib'
- '/home/me/program/local/lib/perl5/i686-linux'
- '/home/me/program/local/lib/perl5'
- '/path/to/some/lib/i686-linux'
- '/path/to/some/lib'
- '/home/me/program/another/lib/i686-linux'
- '/home/me/program/another/lib'
- '/home/me/perl/lib/site_perl/5.18.1/i686-linux'
- '/home/me/perl/lib/site_perl/5.18.1'
- '/home/me/perl/lib/5.18.1/i686-linux'
- '/home/me/perl/lib/5.18.1'
- '.'
</code></pre>

<p>In the production environment:</p>

<pre><code>me@production /app/program$ ./prg
using perl '/approved/perl/bin/perl', @INC contains:
- '/app/program/lib'
- '/app/program/local/lib/perl5/i686-linux'
- '/app/program/local/lib/perl5'
- '/approved/lib/i686-linux'
- '/approved/lib'
- '/approved/perl/lib/site_perl/5.18.1/i686-linux'
- '/approved/perl/lib/site_perl/5.18.1'
- '/approved/perl/lib/5.18.1/i686-linux'
- '/approved/perl/lib/5.18.1'
- '.'
</code></pre>

<p>One last hint! If you cannot manage to install <code>wrapperl</code> somewhere
in the <code>PATH</code> in all the environments, you can either do some shell
wrapping (but this would somehow make wrapperl slightly overkill
probably) or use an approach based on symbolic links. If this is the
case:</p>

<ul>
  <li>rename your program <code>prg</code> as <code>prg.pl</code>, i.e. ending in suffix <code>.pl</code></li>
  <li>in the same directory, create a symbolic link named <code>prg</code> and pointing
to the location of <code>wrapperl</code> (which could be in the very same directory
if you plan to ship wrapperl as well)</li>
</ul>

<p>With this setup, when you run the symbolic link, it will just run the
associated <code>.pl</code> file with the settings in the <code>wrapperl.env</code> file.</p>

<p>That’s all folks!</p>

<h1 id="synopsys">SYNOPSYS</h1>

<pre><code># Minimal setup: create a "wrapperl.env" file.
# It is a Perl program to set up the right environment.
# Two handy functions PERL5LIB() and PERL() are all you need usually
shell$ cat wrapperl.env
PERL5LIB(qw&lt; lib llib &gt; [qw&lt; /path/to/lib /path/to/other/lib &gt;]);
PERL('/path/to/bin/perl');

# You can have a different "wrapperl.env" on each directory.
# What is the one that we would see from here? "wrapperl" can
# tell you this with -e | --env
shell$ wrapperl -e
/path/to/wrapperl.env

# If you also provide a parameter to -e | --env, it will tell
# you which environment file will be seen by the provided
# parameter (that is of course expected to be a path)
shell$ wrapperl -e /path/to/a/wrapperl/symlink
/path/to/a/wrapper.env

# Time to make it work! Option -x | --exec means calling it
# as if it were the chosen perl with the configurations in
# "wrapperl.env"
shell$ wrapperl -x -le 'print $^X'
/path/to/bin/perl

# Option -s | --sibling allows to call programs that are
# usually shipped with perl, e.g. perlthanks, podchecker, etc.
shell$ wrapperl -s podchecker myprogram.pl

# Another useful option is -d | --doc to call perldoc quickly,
# so the following ones are equivalent but the latter is less typing
shell$ wrapperl -s perldoc Module::Name
shell$ wrapperl -d Module::Name

# If the first parameter is not supported by "wrapperl" directly,
# it will be considered a perl program to be executed along with
# its own parameters. This makes it handy to use wrapperl in
# hash-bang setups. The program's *realpath* is also used as the
# starting point for searching wrapperl.env, so that symbolic
# links to your program should work as expected
shell$ wrapperl myprogram.pl --foo bar

# You can symlink pointing to wrapperl and it will do some magic.
# Call the real program a name ending with ".pl" (e.g. "prg.pl")
# and symlink wrapperl with the same name withouth the extension
# (e.g. "prg"). This is what will happen:
shell$ ls -l
-rw-r--r-- 1 me me 74 Apr 23 22:20 wrapperl.env
lrwxrwxrwx 1 me me  8 Apr 23 22:51 prg -&gt; /path/to/wrapperl
-rwxr-xr-x 1 me me 74 Apr 23 22:28 prg.pl

shell$ cat prg.pl
#!/usr/bin/env perl
print "using perl '$^X', \@INC contains:\n";
print "- '$_'\n" for @INC;

shell$ cat wrapperl.env
$ENV{PERL5LIB} = '/path/to/some/lib:/path/to/another/lib';
$PERL = '/path/to/bin/perl';

shell$ which perl
/usr/bin/perl

# If you call the program directly, wrapperl is not used of course
shell$ ./prg.pl
using perl '/usr/bin/perl', @INC contains:
- '/etc/perl'
- '/usr/local/lib/perl/5.14.2'
- '/usr/local/share/perl/5.14.2'
- '/usr/lib/perl5'
- '/usr/share/perl5'
- '/usr/lib/perl/5.14'
- '/usr/share/perl/5.14'
- '/usr/local/lib/site_perl'
- '.'

# On the other hand, if you call the "prg" symlink to wrapperl,
# the same program above will be called, but with the perl and
# options set in "wrapperl.env"
shell$ ./prg
using perl '/path/to/bin/perl', @INC contains:
- '/path/to/another/lib/i686-linux'
- '/path/to/another/lib'
- '/path/to/some/lib/i686-linux'
- '/path/to/some/lib'
- '/path/to/lib/site_perl/5.18.1/i686-linux'
- '/path/to/lib/site_perl/5.18.1'
- '/path/to/lib/5.18.1/i686-linux'
- '/path/to/lib/5.18.1'
- '.'

# There are two symlinks/names that trigger a special behaviour,
# namely "perl" and "perldoc" that do what you think
shell$ ls -l
lrwxrwxrwx 1 me me  8 Apr 23 21:51 perl -&gt; /path/to/wrapperl
lrwxrwxrwx 1 me me  8 Apr 23 22:46 perldoc -&gt; /path/to/wrapperl

# The following two are therefore equivalent (and no, the
# double "-x" is not an error, because the first is consumed by
# "wrapperl" and the second one is for the invoked perl)
shell$ ./perl -x /path/to/my/program.pl
shell$ wrapperl -x -x /path/to/my/program.pl

# These three are equivalent too
shell$ ./perldoc My::Module
shell$ wrapperl -d My::Module
shell$ wrapperl -s perldoc My::Module

# Last, if you manage to install wrapperl somewhere in the PATH
# you can spare the symbolic link and use the hash bang directly!
shell$ cat hashbanged-program
#!/usr/bin/env wrapperl
print "using perl $^X\n";
print "$_\n" for @INC;

shell$ ./hashbanged-program
using perl '/path/to/bin/perl', @INC contains:
- '/path/to/another/lib/i686-linux'
- '/path/to/another/lib'
- '/path/to/some/lib/i686-linux'
- '/path/to/some/lib'
- '/path/to/lib/site_perl/5.18.1/i686-linux'
- '/path/to/lib/site_perl/5.18.1'
- '/path/to/lib/5.18.1/i686-linux'
- '/path/to/lib/5.18.1'
- '.'
</code></pre>

<h1 id="description">DESCRIPTION</h1>

<p>This program lets you wrap a perl program with some local-specific
configurations.</p>

<p>Why would you do this, e.g. as opposed to modifying the
<em>hash-bang</em> line or setting <code>PERL5LIB</code>, or calling the perl
executable directly? Well, lazyness of course, but also the fact
that in different environments the same program might need different
configurations, and changing those configurations possibly in many
little Perl programs quickly becomes an error-prone hassle.</p>

<p><code>wrapperl</code> provides you with a consistent, minimal and easy to setup
way to concentrate local-specific configurations in the
<a href="#the-wrapperl-env-file">“The <code>wrapperl.env</code> File”</a>, and be sure
that you will call your Perl program(s) with the right setup every time.</p>

<p><code>wrapperl</code>’s behaviour strongly depends on its name. That is, if
you leave it as <code>wrapperl</code> it behaves in a specific way, while
if you name it differently then it does something else.</p>

<p>You have several options to do call <code>wrapperl</code> with a different name:</p>

<ul>
  <li>you just copy it with a different name. It works but it’s also ugly
and it will be a hassle every time you want to upgrade (but chances are
you will not need. so don’t worry too much)</li>
  <li>you create a symbolic link. Works if your filesystem supports them,
is robust and allows you to avoid touching the main program</li>
  <li>if you can put <code>wrapperl</code> somewhere in the path in all your
environments, and your system supports the <em>hash-bang</em> system
(i.e. you’re in some Unix-ish system), you can just set it inside
the main program and avoid having anything more. Very clean and
suggested if possible!</li>
</ul>

<p>The following sections start by describing the <code>wrapperl.env</code> file
you should set up, then describe the behaviour in the different
conditions; among them, most probably you will be interested into
<a href="#named-something-else">“Named Something Else”</a>.</p>

<h2 id="the-wrapperlenv-file">The <code>wrapperl.env</code> File</h2>

<p>The <code>wrapperl.env</code> file is at the heart of the localization of
your configurations.</p>

<h3 id="contents">Contents</h3>

<p>The file is a standard Perl program. It will be called using whatever
<em>default</em> perl is found, that is not what you are looking for most
probably (otherwise you would probably not be using <code>wrapperl</code> at
all). You can do whatever setting inside it, while most probably you
will be interested in setting the environment variable <code>PERL5LIB</code>
to point towards the library directories you want to include in
<code>@INC</code>, and also set the right Perl executable to use.</p>

<p>You can affect how <code>wrapperl</code> works by calling the following
functions from within a <code>wrapperl.env</code> file (you should normally
only need the first two anyway):</p>

<ul>
  <li>
    <p><strong>PERL($path)</strong></p>

    <p>the path to the perl to use for invoking the other programs.</p>

    <p>By default it is set to the same perl that is executing <code>wrapperl</code>,
  namely <code>$^X</code>, just in case you need to setup <code>PERL5LIB</code> only.</p>
  </li>
  <li>
    <p><strong>PERL5LIB(@items)</strong></p>

    <p>set the environment variable <code>PERL5LIB</code> according to your needs. You
  can pass a list of items, each of which can be:</p>

    <ul>
      <li>a string, that is interpreted as a relative path starting from the
  same directory as where <code>wrapperl.env</code> is put. This allows e.g. to
  make sure you can point towards sub-directories <code>lib</code> and
  <code>local/lib/perl5</code> inside your project’s root directory, provided you
  also put <code>wrapperl.env</code> in the same directory</li>
      <li>a reference to an array of strings. These strings are passed unchanged
  in the environment variable, so that you can set either absolute
  paths or paths relative to the current directory.</li>
    </ul>

    <p>You should normally need to set paths relative to the root directory
  of your project, this is why it’s slightly easier to set them instead
  of absolute paths or paths relative to the current directory.</p>

    <p>Any previous value of the environment variable <code>PERL5LIB</code> is wiped
  out, and this is considered a feature. If you really want to preserve
  it somewhere, just pass its value inside a reference to an array like
  this:</p>

    <pre><code>  PERL5LIB(..., [$ENV{PERL5LIB}], ...);
</code></pre>
  </li>
  <li>
    <p><strong>ME($path)</strong></p>

    <p>the location of the original program invoked. When calling <code>wrapperl</code>
  with a different name (see <a href="#named-something-else">“Named Something Else”</a>), it is used
  together with <code>$SUFFIX</code> described below to form the name of the
  program <code>$ME$SUFFIX</code> that will be called with the new <code>$PERL</code>. In
  general you should not need to fiddle with this.</p>
  </li>
  <li>
    <p><strong>PERLDOC($name)</strong></p>

    <p>The name of the <code>perldoc</code> utility installed along with <code>$PERL</code>.</p>

    <p>By default it is set to <code>perldoc</code>, and you probably do not need
  to change it.</p>
  </li>
  <li>
    <p><strong>SUFFIX($string)</strong></p>

    <p>a suffix that is appended to the name of the invoked program when
  calling <code>wrapperl</code> with a different name (see
  <a href="#named-something-else">“Named Something Else”</a>). Makes sense only if you are using the
  symbolic linking method and not the <em>hash-bang</em> approach.</p>

    <p>Assuming that <code>$ME</code> holds the value set by <code>ME()</code> and <code>$SUFFIX</code>
  the value set by <code>SUFFIX</code>,
  the called program will be <code>$ME$SUFFIX</code>, so if <code>$SUFFIX</code> is
  <code>.pl</code>, you are expected to call your <em>real</em> program the same
  as your symbolic link (or renamed <code>wrapperl</code> program) but with
  <code>.pl</code> appended. Example:</p>

    <pre><code>  shell$ ls -l
  lrwxrwxrwx 1 me me  8 Apr 23 22:51 prg -&gt; /path/to/wrapperl
  -rwxr-xr-x 1 me me 74 Apr 23 22:28 prg.pl
</code></pre>

    <p>If your system is picky about how files should be named (e.g.
  Windows might put some restrictions to what it considers as
  <em>executables</em>), then you can do your transformations directly
  using <code>ME()</code> and set <code>SUFFIX('')</code> to the empty string in order
  to select the <em>real</em> program to call.</p>

    <p>By default, it is set to <code>.pl</code> and you should not need
  to change it.</p>
  </li>
</ul>

<h3 id="loading">Loading</h3>

<p>The <code>wrapperl.env</code> file is loaded via a <code>do</code>, so you are warned
about any possible security issue.</p>

<p>The invocation is supposed to return a true value (in Perl terms),
otherwise the execution will be stopped.</p>

<h3 id="position">Position</h3>

<p>Depending on how <code>wrapperl</code> is called, the <code>wrapperl.env</code> file is
searched in different locations.</p>

<p>One or more
<em>starting positions</em> will be considered, and used to perform a search
from that position upwards in the filesystem. For example, if the
starting point is <code>/path/to/some/internal/sub</code>, then the following
paths will be searched for <code>wrapperl.env</code>:</p>

<pre><code>/path/to/some/internal/sub
/path/to/some/internal
/path/to/some
/path/to
/path
/
</code></pre>

<p>An exception is thrown if no <code>wrapperl.env</code> file is found during the
search in all the starting points.</p>

<p>The <em>standard resolution</em> of the <code>wrapperl.env</code> file is performed starting
from the current working directory, then from the user’s home directory as
read from the <code>HOME</code> environment variable.</p>

<p>In some cases, the starting position will be some other specific
location. For example, when <code>wrapperl</code> is <a href="#named-something-else">“Named Something Else”</a>,
the only starting location will be the path to the link to
<code>wrapperl</code>, (i.e. what is used to initialize <code>$ME</code>).</p>

<h2 id="direct-invocation">Direct Invocation</h2>

<p>Direct invocation of <code>wrapperl</code> (i.e. without changing the name
when calling it) is subject to the processing of some
options (see <a href="#options">“OPTIONS”</a>).</p>

<p>Unless otherwise noted, the resolution of the <code>wrapperl.env</code> file
is the <em>standard</em> one as described in section <a href="#position">“Position”</a>.</p>

<p>If none of the options in <a href="#options">“OPTIONS”</a> is recognized, the selected
perl via <code>PERL()</code> is invoked with whatever argument list is provided. This
is equivalent to using the <code>-x|--exec</code> option, except that the
first option is not stripped away in this case and also that the first
item in the command line list is assumed to be the path to a program and
its path will be used as the starting position for <code>wrapperl.env</code>
location resolution.</p>

<p>Option <code>-d|--doc</code> helps you call <code>perldoc</code>, or whatever is set in
<code>$PERLDOC</code>. This will be useful in order to use the <code>perldoc</code> that is
shipped with the selected <code>$PERL</code>, and more importantly with the same
options (e.g. <code>PERL5LIB</code>) set in <code>wrapperl.env</code>, so that you will be
able to find whatever module is installed in your personalized paths.</p>

<p>Option <code>-e|--env</code> helps you find out what will be the <code>wrapperl.env</code>
used, so that you can double check that it is the one you are expecting
and its contents. If you also pass a path in the command line, it will
be used as the starting point for searching <code>wrapperl.env</code>, otherwise
the standard resolution process is used.</p>

<p>Option <code>-s|--sibling</code> allows you to call one of the Perl programs
that are present in the same directory as <code>$PERL</code>, much in the same
way as described for <code>perldoc</code> above. For example, if you want to
check the POD documentation in <code>YourModule.pm</code> using the <code>podchecker</code>
that is shipped with the perl you indicated in <code>wrapperl.env</code>:</p>

<pre><code>shell$ wrapperl -s podchecker
</code></pre>

<p>Last, option <code>-x|--exec</code> allows you to call <code>$PERL</code> with the options
set in <code>wrapperl.env</code> (where the resolution process starts from the
current directory or from the <code>HOME</code> directory).</p>

<h2 id="named-perl">Named <code>perl</code></h2>

<p>This name makes <code>wrapperl</code> transform into a call to what set as
<code>PERL()</code>, including any command line option provided.</p>

<p>The resolution of the <code>wrapperl.env</code> file is performed according to
the <em>standard resolution</em> process explained in section <a href="#position">“Position”</a>,
starting from the location of the symbolic link.</p>

<h2 id="named-perldoc">Named <perldoc></perldoc></h2>

<p>This name calls the <code>perldoc</code> set via <code>PERLDOC()</code> and located in the
same directory as what set via <code>PERL()</code>, including any command line
option provided. The behaviour is the same as calling <code>wrapperl</code> with
option <code>-d|--doc</code>, with the exception of the resolution process.</p>

<p>The resolution of the <code>wrapperl.env</code> file is performed according to
the <em>standard resolution</em> process explained in section <a href="#position">“Position”</a>,
starting from the location of the symbolic link.</p>

<h2 id="named-something-else">Named Something Else</h2>

<p>If your system(s) have <code>/usr/bin/env</code> and you can put <code>wrapperl</code>
somewhere in the <code>PATH</code>, just set the <em>hash-bang</em> to:</p>

<pre><code>#!/usr/bin/env wrapperl
</code></pre>

<p>and you’re done. If not, read on.</p>

<p>Assuming that you have set up your <code>wrapperl.env</code> file (see
<a href="#the-wrapperl-env-file">“The <code>wrapperl.env</code> File”</a>), you are only two steps away from
using <code>wrapperl</code> to automate calling your program with the right
setup:</p>

<ul>
  <li>
    <p>you can write your program without worrying about which perl will
be used to call it or where the libraries are installed. Your only
constraint is to name it ending with what is set for <code>SUFFIX()</code> or
do some magic using <code>ME()</code> in <code>wrapperl.env</code>.</p>

    <p>By default, it suffices that you name your program ending with
  <code>.pl</code>. For example, we will assume that your program is called
  <code>prg.pl</code>.</p>
  </li>
  <li>
    <p>You set up a copy to <code>wrapperl</code> to be called the same as your
program, but without the <code>SUFFIX</code>. In the example, your copy
would be called <code>prg</code>.</p>

    <p>To make the copy you don’t really have to make a copy! A symbolic
  link is sufficient, if your filesystem supports them.</p>
  </li>
</ul>

<p>This is really it! Now, every time you need to run your program…
don’t do it, execute the <code>wrapperl</code> copy instead! That is, in the
example you would call <code>prg</code>, and it would in turn call your
<code>prg.pl</code> but after reading all the configurations
in <code>wrapperl.env</code>.</p>

<p>See <a href="#tl-dr">“TL;DR”</a> for a complete and commented example.</p>

<h1 id="options">OPTIONS</h1>

<p>When invoked with name <code>wrapperl</code>, this program supports the following
options. Note that you can provide one of them as the first option, and
anyone not appearing here will actually be used for invoking the
perl indicated in the <code>wrapperl.env</code> file.</p>

<p>In all the options below, unless otherwise noted, the
<em>standard resolution process</em> for searching <code>wrapperl.env</code> is
used (see <a href="#position">“Position”</a>).</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>**-d</td>
          <td>–doc [arg1 arg2 …]**</td>
        </tr>
      </tbody>
    </table>

    <p>invoke whatever program is set in the <code>$PERLDOC</code> variable in package
  <code>main</code> (<code>perldoc</code> by default), using <code>$PERL</code> and the settings inside
  <code>wrapperl.env</code>.</p>

    <p>The <code>$PERLDOC</code> program is expected to be placed in
  the same directory as the selected <code>$PERL</code>.</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>**-e</td>
          <td>–env [path]**</td>
        </tr>
      </tbody>
    </table>

    <p>print the path to the <code>wrapperl.env</code> file.</p>

    <p>If a <code>path</code> is provided after this option, it is used as a starting
  location for searching <code>wrapperl.env</code>, otherwise the
  <em>standard resolution process</em> is used. See <a href="#position">“Position”</a> for additional
  details.</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>**-s</td>
          <td>–sibling name [arg1 arg2 …]**</td>
        </tr>
      </tbody>
    </table>

    <p>invoke a <em>sibling</em> program, i.e. a program that is shipped along
  with <code>$PERL</code> and is located in the same directory.</p>

    <p>The program is run with <code>$PERL</code> and the configurations set inside
  <code>wrapperl.env</code>. Any argument is provided on the command line is
  passed along to the sibling program. This will thus work fine
  when the sibling is a Perl program, but not for binary executables.</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>**-x</td>
          <td>–exec program [arg1 arg2 …]**</td>
        </tr>
      </tbody>
    </table>

    <p>invoke <code>$PERL</code> with the provided program and arguments, after loading
  the options in <code>wrapper.env</code>. The <code>wrapperl.env</code> resolution is performed
  starting from the <em>realpath</em> of <code>program</code> (see <a href="#cwd">“Cwd”</a>).</p>
  </li>
</ul>

<h1 id="diagnostics">DIAGNOSTICS</h1>

<ul>
  <li>
    <p><code>could not find wrapperl.env</code></p>

    <p><code>wrapperl</code> tried to find <code>wrapperl.env</code> in the same directory as
  the symbolic link to it, or in any ancestor directory, but failed to
  find one.</p>
  </li>
  <li>
    <p><code>errors loading '%s'</code></p>

    <p>loading the <code>wrapperl.env</code> was not successful, i.e. the invocation
  via <code>do</code> did not produce a true value. The placeholder provides
  the location of the offending file.</p>
  </li>
  <li>
    <p><code>failed execution of %s</code></p>

    <p><code>wrapperl</code> tried to execute the command (reported in the error message)
  but failed. The placeholder provides the offending command.</p>
  </li>
  <li>
    <p><code>something went really wrong</code></p>

    <p>you shouldn’t ever see this message, if you do it’s a bug!</p>
  </li>
</ul>

<h1 id="configuration-and-environment">CONFIGURATION AND ENVIRONMENT</h1>

<p><code>wrapperl</code> does not have a configuration per-se, but is of course
relying on the presence of a <code>wrapperl.env</code> file for proper
functioning - see <a href="#description">“DESCRIPTION”</a>.</p>

<h1 id="dependencies">DEPENDENCIES</h1>

<p><code>wrapperl</code> relies on modules that are part of any standard Perl
distribution as of release 5.6.0.</p>

<h1 id="bugs-and-limitations">BUGS AND LIMITATIONS</h1>

<p>Please report bugs and hopefully solutions through the GitHub
repository at <a href="https://github.com/polettix/wrapperl">https://github.com/polettix/wrapperl</a>.</p>

<h1 id="author">AUTHOR</h1>

<p>Flavio Poletti <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#112;&#111;&#108;&#101;&#116;&#116;&#105;&#120;&#064;&#099;&#112;&#097;&#110;&#046;&#111;&#114;&#103;">&#112;&#111;&#108;&#101;&#116;&#116;&#105;&#120;&#064;&#099;&#112;&#097;&#110;&#046;&#111;&#114;&#103;</a></p>

<h1 id="license-and-copyright">LICENSE AND COPYRIGHT</h1>

<p>Copyright (c) 2015, Flavio Poletti <code>polettix@cpan.org</code>.</p>

<p>This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0. Please read
the full license in the <code>LICENSE</code> file inside the distribution,
as you can find at <a href="https://github.com/polettix/wrapperl">https://github.com/polettix/wrapperl</a>.</p>

<p>This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.</p>
      </div>
   </body>
</html>
