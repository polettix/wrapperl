#!/usr/bin/env perl
use strict;
use warnings;
use File::Spec::Functions qw<
  rel2abs
  splitpath
  splitdir
  catdir
  catpath
  file_name_is_absolute
>;
use Cwd qw< getcwd realpath >;
use Pod::Usage qw< pod2usage >;
my $VERSION = '0.02';
our $SUFFIX = '.pl';

our $ME = absolute($0);

my @alternatives = (
   [
      qr{(?mxs: \A wrapperl \z)},
      \&action_wrapperl
   ],
   [
      qr{(?mxs: \A perl \z)},
      \&action_perl
   ],
   [
      qr{(?mxs: \A perldoc \z)},
      \&action_perldoc
   ],
   [
      qr{.}, \&action_default
   ],
);

my (undef, undef, $basename) = splitpath($ME);
for my $candidate (@alternatives) {
   my ($match, $callback) = @$candidate;
   next unless $basename =~ m{$match};
   $callback->();
}

die "something went really wrong\n";

sub load_envfile {
   my ($envfile) = @_;
   my $retval = do $envfile
      or die "errors loading '$envfile'\n";
   return $retval;
}

sub find_envfile {
   my ($start) = @_;
   my ($volume, $directories) = splitpath($start, -d $start);
   my @path = splitdir($directories);
   my $envfile;
   while (@path) {
      my $candidate = catpath($volume, catdir(@path), 'wrapperl.env');
      return $candidate if -e $candidate;
      pop @path;
   } ## end while (@path)
   die "could not find wrapperl.env\n" unless defined $envfile;
   return; # never reached
}

sub absolute {
   my ($path) = @_;
   return $path if file_name_is_absolute($path);
   return rel2abs($path);
}

sub envfile_cwd_or_home {
   return eval { find_envfile(getcwd()) }
      || find_envfile($ENV{HOME});
}

sub myexec {
   my @command = @_;
   exec {$command[0]} @command;
   die "failed execution of @command\n";
}

sub action_wrapperl {
   my $envfile = @ARGV ? find_envfile(@ARGV) : envfile_cwd_or_home();
   print {*STDOUT} "$envfile\n";
   exit 0;
}

sub action_perl {
   my $perl = load_envfile(envfile_cwd_or_home());
   myexec($perl, @ARGV);
}

sub action_perldoc {
   my $perl = load_envfile(envfile_cwd_or_home());
   my ($v, $d) = splitpath($perl);
   my (undef, undef, $basename) = splitpath($ME);
   my $perldoc = catpath($v, $d, $basename);
   myexec($perl, $perldoc, @ARGV);
}

sub action_default {
   my $perl = load_envfile(find_envfile($ME));
   my $target = "$ME$SUFFIX";
   myexec($perl, $target, @ARGV);
}

__END__

=pod

=encoding utf-8

=head1 NAME

wrapperl - simple wrapper system for Perl

=head1 SYNOPSYS

   # the "real" Perl program goes into somename.pl
   $ vi somename.pl # and put your stuff inside

   # the "wrapper" is a symlink to wrapperl, named somename
   # in same directory as somename.pl
   $ ln -s /path/to/wrapperl somename

   # the configuration is put in a wrapperl.env file, which is
   # actually a Perl file with a configuration inside. It is put
   # in the same directory or any ancestor as somename.pl/somename
   $ cat wrapperl.env
   $ENV{PERL5LIB} = '';
   '/path/to/perl';

=head1 DESCRIPTION

This program lets you wrap a perl program with some local-specific
configurations.

=head2 Normal Usage

Using it is simple and has three steps:

=over

=item 1.

you assign your program a name that ends in C<.pl>, e.g. C<somename.pl>;

=item 2.

you create a symbolic link to C<wrapperl> inside the same directory
as your program, and name the symbolic link the same as the program
but without the C<.pl> extension, e.g. C<somename>;

=item  3.

you create a small Perl program called C<wrapperl.env> located inside the
same directory as the main program, or any of its ancestors (the first
that is found while backtracking is used).

=back

This small program in the third step is supposed
to set the needed environment variables, like C<$ENV{PERL5LIB}>, and also
return the path to the C<perl> program to use for invoking the program
in the modified environment. If you want to reuse the same C<perl>, just
use C<$^X> as the last statement in your C<wrapperl.env> file, otherwise
put a string with the desired path.

This is really it! Now you can call the symbolic link created in step
2, and the real program in step 1 will be called actually, in the modified
environment and with the C<perl> you set inside the C<wrapperl.env> file.

=head2 Special Names

As it should be evident at this point, this program acts depending on
the name it is called with. While in general the behaviour is what
has been described in the previous section, there are some names that
are treated in a special way:

=over

=item B<< wrapperl >>

when invoked directly (or anyway through a symlink called C<wrapperl>),
the program will show what environment file C<wrapperl.env> is used. You
can pass a path to set the starting point for the research of the file,
otherwise it will start from the current working directory and in case
of absence from the home directory.

=item B<< perl >>

this name makes C<wrapperl> transform into a call to the C<perl> indicated
by the C<wrapperl.env> file, with all following command line options.

=item B<< perldoc >>

this name calls the C<perldoc> program located in the same directory
as the loaded C<perl>, with following parameters.

=back

This means that you can symlink with name C<perl> and get a way to
invoke C<perl> with the right parameters set in the C<wrapperl.env>
file.

=head2 C<wrapperl.env>

The C<wrapperl.env> file is executed via a C<do>, so you are warned
about any possible security issue.

You can of course do whatever you want in this file, including the
modification of the relevant variables:

=over

=over C<$ME>

this is the absolute path to the invoked program (most probably, a
symlink to C<wrapperl>). In case of "regular" invocation, i.e. through
a name that is not special, the real target is derived as
C<$ME$SUFFIX>, so if you modify either one you can influence which
target name to use.

In case of C<perldoc>, C<$ME> is used to find the last part (i.e.
the I<basename>) and is then used B<without> the C<$SUFFIX>.

=over C<$SUFFIX>

this is a suffix appended to the invoked name C<$ME> to find the real
Perl program to start. Defaults to C<.pl>.

=back


=head1 OPTIONS

This program really has no options.

=head1 DIAGNOSTICS

=over

=item C<< could not find wrapperl.env >>

C<wrapperl> tried to find C<wrapperl.env> in the same directory as
the symbolic link to it, or in any ancestor directory, but failed to
find one.

=item C<< reading %s failed >>

the C<wrapperl.env> file that was found cannot be read properly. The
error message indicates the path to the troublesome file.

=item C<< failed execution of %s >>

C<wrapperl> tried to execute the command (reported in the error message)
but failed.

=back

=head1 CONFIGURATION AND ENVIRONMENT

C<wrapperl> does not have a configuration per-se, but is of course
relying on the presence of a C<wrapperl.env> file for proper
functioning - see L</DESCRIPTION>.

=head1 DEPENDENCIES

C<wrapperl> relies on modules that are part of any standard Perl
distribution as of release 5.6.0.

=head1 BUGS AND LIMITATIONS

Please report bugs and hopefully solutions through the GitHub
repository at L<https://github.com/polettix/wrapperl>.

=head1 AUTHOR

Flavio Poletti <polettix@cpan.org>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015, Flavio Poletti C<polettix@cpan.org>.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0. Please read
the full license in the F<LICENSE> file inside the distribution,
as you can find at L<https://github.com/polettix/wrapperl>.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
